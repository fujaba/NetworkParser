// clean --refresh-dependencies build
// -PReleaseBuild 


buildscript {
	repositories {
		maven {
			url "https://plugins.gradle.org/m2/"
		}
	}
	dependencies {
		classpath "com.moowork.gradle:gradle-node-plugin:[1,)"
	}
}

plugins {
  id "org.sonarqube" version "3.3"
  id 'java'
  id 'eclipse'
  id 'idea'
  id 'jacoco'
//  id 'maven-publish'
  id "com.github.spotbugs" version "5.0.5"
  id 'checkstyle'
}

// MAJOR VERSION - Manually set
//----------------------
group = "de.uniks"
ext{
	majorNumber = 4
}
//----------------------

apply from: 'gradle/tasks.gradle'
//apply from: 'gradle/mavencentral.gradle'
//apply from: 'gradle/artifactory.gradle'
repositories {
	maven {
		url "https://repo.eclipse.org/content/groups/releases/"
	}
}
test {
	// enable TestNG support (default is JUnit)
	useJUnit {
		dependencies {
			implementation("org.junit.jupiter:junit-jupiter-api:[5,)")
			implementation("org.junit.jupiter:junit-jupiter-engine:[5,)")
			implementation("org.junit.jupiter:junit-jupiter-params:[5,)")
			//testCompile group: 'org.xerial', name: 'sqlite-jdbc', version: '[3,)'
		}
	}
	//we want display the following test events
    testLogging {
        events "FAILED", "SKIPPED"
		exceptionFormat "short"
		showStackTraces	true
		showStandardStreams true
		showCauses true
    }
	reports.junitXml {
		enabled true
		destination file("${buildDir}/test-results/xml")
	}
	reports.html.destination = file("$buildDir/test-results/junit_html")
	jacoco.destinationFile = file("${buildDir}/test-results/test.exec")
}

def execute(String... args) {
	try {
		if(args.length == 1) {
			args = args[0].split(" ")
		}
		ByteArrayOutputStream stdOutput = new ByteArrayOutputStream()

		exec{
			commandLine args
			standardOutput = stdOutput
		}
		stdOutput.toString()
	}catch(Exception e) {
	}
		"";
}

def copyFile(String source, String dest) {
	InputStream is = null;
	OutputStream os = null;
	try {
		if(new File(source).exists() == false) {
			return;
		}
		is = new FileInputStream(new File(source));
		os = new FileOutputStream(new File(dest));
		byte[] buffer = new byte[1024];
		int length;
		while ((length = is.read(buffer)) > 0) {
			os.write(buffer, 0, length);
		}
	} finally {
		if(is != null) {
			is.close();
		}
		if(os != null) {
			os.close();
		}
	}
}


def unzip(String src, String dest) {
	byte[] buffer = new byte[1024];
	java.util.zip.ZipInputStream zis = new java.util.zip.ZipInputStream(new FileInputStream(src));
	java.util.zip.ZipEntry zipEntry = zis.getNextEntry();
	while(zipEntry != null) {
		String fileName = zipEntry.getName()
		if(zipEntry.isDirectory() == false) {
			File newFile = new File(dest+"/" + fileName)
			if(newFile.getParentFile().exists() == false) {
				newFile.getParentFile().mkdirs()
			}
			FileOutputStream fos = new FileOutputStream(newFile)
			int len
			while ((len = zis.read(buffer)) > 0) {
				fos.write(buffer, 0, len);
			}
			fos.close()
		}
		zipEntry = zis.getNextEntry();
	}
	zis.closeEntry();
	zis.close();
}


def delete(File file) {
	if(file.isDirectory()) {
		File[] contents = file.listFiles();
		if (contents != null) {
			for (File f : contents) {
				deleteDir(f);
			}
		}
	}
	file.delete();
}

def unzipPassword(fileName, password) {
	def urls=[]
	sourceSets.main.runtimeClasspath.files.each {urls.add(it.toURL())}
	sourceSets.main.output.files.each {urls.add(it.toURL())}
	files('build/classes/main18').each {urls.add(it.toURL())}
	try {
		ClassLoader cl = new URLClassLoader(urls.toArray(new URL[urls.size()]))
		Class<?> myClass = cl.loadClass("de.uniks.networkparser.ext.io.ZipContainer");
		
		//def method = myClass.getMethod("decoding", new Class<?>[]{String[].class})
		//return method.invoke(null, new Object[] {new String[] {fileName, password}});
	}catch(Exception e) {
		e.printStackTrace()
	}
}

if(JavaVersion.current() != JavaVersion.VERSION_1_8){
	println "JavaVersion: " + JavaVersion.current() + " (1.9)"
	sourceCompatibility = 1.9
	targetCompatibility = 1.9
} else {
	println "JavaVersion: " + JavaVersion.current() + " (1.8)"
	sourceCompatibility = 1.8
	targetCompatibility = 1.8
}

idea {
	project {
		// jdkName = '1.7'
		// languageLevel = '1.7'
	}
}

artifacts { 
	archives buildCoreJar17, buildCoreJar18, buildCoreJar19, buildSourceJar, buildSourceJar18, buildMinCoreJar, buildJavadoc, buildGitJar, buildMinJsonJar
}

wrapper {
	gradleVersion = '6.6.1'
}
jacoco.toolVersion = "0.8.+"

jacocoTestReport {
	group = "Reporting"
	description = "Generate Jacoco coverage reports after running tests."
	executionData(files("${buildDir}/test-results/test.exec"))
	reports {
		xml {
			enabled = true
			//Following value is a file
			destination = new File("${buildDir}/test-results/jacoco.xml")
		}
		csv{
			destination = new File("${buildDir}/test-results/report.csv")
			enabled = true
		}
		html {
			enabled = true
			//Following value is a folder
			destination = new File("${buildDir}/test-results/html")
		}
	}
	afterEvaluate {
		classDirectories.from = files(classDirectories.files.collect {
			fileTree(dir: it, exclude: ['**/javafx/**'])
		})
	}
}

if (project.hasProperty('branch')) {
	new ProcessBuilder("git", "checkout", findProperty('branch')).start()
}

test.finalizedBy jacocoTestReport

defaultTasks 'test', 'jacocoTestReport', 'buildJavadoc', 'buildGitJar'

sonarqube {
  properties {
    property "sonar.projectKey", "StefanLindel_NetworkParser"
    property "sonar.organization", "stefanlindel"
    property "sonar.host.url", "https://sonarcloud.io"
  }
}

javadoc {
  options.memberLevel = JavadocMemberLevel.PUBLIC
}
checkstyle {
	checkstyleTest.enabled = false
}
spotbugsTest {
    ignoreFailures = true
	spotbugsTest.enabled = false
}
 
tasks.withType(Checkstyle) {
	configFile = file("src/test/resources/de/uniks/networkparser/test/networkparser.xml")
	reports {
		xml.enabled true
		xml.destination = new File("build/checkStyle.xml")
		html.enabled true
		html.destination = new File("build/checkStyle.html")
	}
	showViolations = false
	ignoreFailures = true
}

task npm(type:JavaExec) {
	errorOutput = System.err
	main = "de.uniks.networkparser.ext.DiagramEditor"
	args 'NPM'
	classpath = (sourceSets.main.compileClasspath + sourceSets.main.output + files('build/classes/main18'))
}

sonarqube {
    properties {
      property("sonar.login", SONAR_TOKEN)
      property("sonar.sourceEncoding", "UTF-8")
    }
}
task extractSignature(){
	doFirst {
		unzipPassword("signiture.zip", System.getenv("SIGNITURE_PASSWORD"))
	}
}
spotbugsMain {
    reports {
        xml {
		  enabled = true
		  destination = new File("${buildDir}/test-results/spotbugs.xml")
		}
		html {
			enabled = true
			destination = new File("${buildDir}/test-results/spotbugs.html")
		}
    }
	excludeFilter = file("lib/spotbug_exlude.xml")
	ignoreFailures = true
}
spotbugsTest {
    reports {
        xml {
		  enabled = true
		  destination = new File("${buildDir}/test-results/spotbugs_test.xml")
		}
		html {
			enabled = true
			destination = new File("${buildDir}/test-results/spotbugs_test.html")
		}
    }
	excludeFilter = file("lib/spotbug_exlude.xml")
	ignoreFailures = true
}

task coveralls() {
	doFirst {
		def urls=[]
		files(configurations.gitVersion).each {urls.add(it.toURL())}
		sourceSets.main.runtimeClasspath.files.each {urls.add(it.toURL())}
		sourceSets.main.output.files.each {urls.add(it.toURL())}
		files('build/classes/main18').each {urls.add(it.toURL())}
		try {
			ClassLoader cl = new URLClassLoader(urls.toArray(new URL[urls.size()]))
			Class<?> myClass = cl.loadClass("de.uniks.networkparser.ext.io.Coveralls");
			Object element = myClass.newInstance();
			def method = myClass.getMethod("execute", Object.class)
			element.reportFile = "build/report.json"
			element.token = COVERALLS_REPO_TOKEN
			element.git = gitVersion
			
			method.invoke(element, new Object[]{null})
		}catch(Exception e) {
			e.printStackTrace()
		}
	}
}
